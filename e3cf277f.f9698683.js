(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{150:function(e,t,i){"use strict";i.r(t),i.d(t,"frontMatter",(function(){return c})),i.d(t,"metadata",(function(){return o})),i.d(t,"rightToc",(function(){return s})),i.d(t,"default",(function(){return d}));var n=i(2),r=i(9),a=(i(0),i(160)),c={id:"grammar",title:"Grammar"},o={id:"specification/grammar",isDocsHomePage:!1,title:"Grammar",description:"Notation",source:"@site/docs\\specification\\grammar.md",permalink:"/docs/specification/grammar",editUrl:"https://github.com/whistle-lang/website/edit/master/website/docs/specification/grammar.md",sidebar:"someSidebar",previous:{title:"Hello, World!",permalink:"/docs/getting-started/hello-world"}},s=[{value:"Notation",id:"notation",children:[]},{value:"The Whistle Grammar Specification",id:"the-whistle-grammar-specification",children:[{value:"Characters, letters and digits",id:"characters-letters-and-digits",children:[]},{value:"Whitespace",id:"whitespace",children:[]},{value:"Comments",id:"comments",children:[]},{value:"Identifiers",id:"identifiers",children:[]},{value:"Keywords",id:"keywords",children:[]},{value:"Operators",id:"operators",children:[]},{value:"Literals",id:"literals",children:[]},{value:"Tips",id:"tips",children:[]},{value:"Expressions",id:"expressions",children:[]}]}],l={rightToc:s};function d(e){var t=e.components,i=Object(r.a)(e,["components"]);return Object(a.b)("wrapper",Object(n.a)({},l,i,{components:t,mdxType:"MDXLayout"}),Object(a.b)("h2",{id:"notation"},"Notation"),Object(a.b)("p",null,"To describe the grammar fo ",Object(a.b)("em",{parentName:"p"},"Whistle"),", ",Object(a.b)("a",Object(n.a)({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form"}),"extended Backus-Naur form (EBNF)"),"\nis used."),Object(a.b)("p",null,"The operator ",Object(a.b)("inlineCode",{parentName:"p"},"...")," represents a range from the toke that comes before to the that comes after as alternatives. For examaple ",Object(a.b)("inlineCode",{parentName:"p"},'"A" ... "C"')," is equivelent to ",Object(a.b)("inlineCode",{parentName:"p"},'"A" | "B" | "C"'),". Line comments are specified using double slashes (",Object(a.b)("inlineCode",{parentName:"p"},"//"),") and continue until a new line character is encountered while multiline comments are nesting and start with ",Object(a.b)("inlineCode",{parentName:"p"},"/*")," and end with ",Object(a.b)("inlineCode",{parentName:"p"},"*/"),"."),Object(a.b)("h2",{id:"the-whistle-grammar-specification"},"The Whistle Grammar Specification"),Object(a.b)("h3",{id:"characters-letters-and-digits"},"Characters, letters and digits"),Object(a.b)("p",null,"There are a few predefined values that could not easily be written as valid EBNF, these are instead written with the value of a comment which describes its content."),Object(a.b)("pre",null,Object(a.b)("code",Object(n.a)({parentName:"pre"},{}),'unicode_character = // any Unicode code point except newline\nunicode_letter    = // any Unicode code point classified as a "Letter"\nunicode_digit     = // any Unicode code point classified as a "Digit"\n\nletter            = unicode_letter | "_"\ndigits_decimal    = { "0" ... "9" }\ndigits_binary     = { "0" | "1" }\ndigits_octal      = { "0" ... "7" }\ndigits_hex        = { "0" ... "9" | "A" ... "F" | "a" ... "f" }\n')),Object(a.b)("h3",{id:"whitespace"},"Whitespace"),Object(a.b)("p",null,"In ",Object(a.b)("em",{parentName:"p"},"Whistle")," whitespace serves no purpose but to separate tokens and if included in a literal that explicitly allows it (string and character literals)."),Object(a.b)("pre",null,Object(a.b)("code",Object(n.a)({parentName:"pre"},{}),'whitespace = " " | "\\t" | "\\r" | "\\n"\n')),Object(a.b)("h3",{id:"comments"},"Comments"),Object(a.b)("p",null,"Just like whitespace comments get ignored unless it is in a literal that explicitly allows it. ",Object(a.b)("em",{parentName:"p"},"Whistle")," provides two comment types: line comments and multiline/inline comments."),Object(a.b)("pre",null,Object(a.b)("code",Object(n.a)({parentName:"pre"},{}),'comment = line_comment | inline_comment\nline_comment   = "//" , { unicode_character } , "\\n"\ninline_comment = "/*" , { unicode_character } , "*/"\n')),Object(a.b)("h3",{id:"identifiers"},"Identifiers"),Object(a.b)("p",null,"Identifiers are mainly used in ",Object(a.b)("em",{parentName:"p"},"Whistle")," to name certain entities such as types, functions and variables. Some identifiers however are reserved as keywords and are not allowed for naming."),Object(a.b)("pre",null,Object(a.b)("code",Object(n.a)({parentName:"pre"},{}),'identifier       = letter , { letter | unicode_digit }\nidentifier_typed = identifier , ":" , identifier\n')),Object(a.b)("h3",{id:"keywords"},"Keywords"),Object(a.b)("p",null,"The following identifiers reserved as keywords in ",Object(a.b)("em",{parentName:"p"},"Whistle")," are currently:"),Object(a.b)("pre",null,Object(a.b)("code",Object(n.a)({parentName:"pre"},{}),"import    as        from\nexport    fun       return\nif        else      while\nloop      break     continue\nvar       val\n")),Object(a.b)("p",null,"And here are some of the planned keywords:"),Object(a.b)("pre",null,Object(a.b)("code",Object(n.a)({parentName:"pre"},{}),"for       in        match\ntype      struct    trait\n")),Object(a.b)("h3",{id:"operators"},"Operators"),Object(a.b)("p",null,"Operators are defined by one or more operator characters coming after each other."),Object(a.b)("pre",null,Object(a.b)("code",Object(n.a)({parentName:"pre"},{}),'operator = { operator_character }\noperator_character = "+" | "-" | "*" | "/"\n                   | "%" | "^" | "=" | ":"\n                   | "." | ";" | "!" | "|"\n                   | "&" | "!" | "<" | ">"\n')),Object(a.b)("h3",{id:"literals"},"Literals"),Object(a.b)("p",null,"Literals in ",Object(a.b)("em",{parentName:"p"},"Whistle")," represent a fixed value."),Object(a.b)("pre",null,Object(a.b)("code",Object(n.a)({parentName:"pre"},{}),'literal         = integer\n                | float\n                | string\n                | char\n                | bool\n\ninteger         = integer_decimal\n                | integer_binary\n                | integer_octal\n                | integer_hex\ninteger_decimal = digits_decimal\ninteger_binary  = "0" , ( "b" | "B" ) , digits_binary\ninteger_octal   = "0" , ( "o" | "O" ) , digits_octal\ninteger_hex     = "0" , ( "x" | "X" ) , digits_hex\n\nfloat           = ( digits_decimal , "." , [ digits_decimal ] , [ exponent ] )\n                | ( digits_decimal , exponent )\n                | ( "." , digits_decimal , exponent )\nexponent        = ( "e" | "E" ) , [ "+" | "-" ] , digits_decimal\n\n\nstring = "\\"" , { unicode_character | "\\n" } , "\\""\n\n\nchar = "\'" , ( unicode_character | "\\n" ) , "\'"\n\nbool = "true" | "false"\n')),Object(a.b)("h3",{id:"tips"},"Tips"),Object(a.b)("p",null,"Tips are in ",Object(a.b)("em",{parentName:"p"},"Whistle")," similar to macros. They tell the compiler certain stuff\nand are very useful for a plethera of reasons. There are two types of tips in\n",Object(a.b)("em",{parentName:"p"},"Whistle"),": line tips and multiline/inline tips."),Object(a.b)("pre",null,Object(a.b)("code",Object(n.a)({parentName:"pre"},{}),'tip       = "#(" , identifier  ,  ")" , ( tip_line | tip_block )\ntip_line  =  { unicode_character } , "\\n"\ntip_block = "{" , { unicode_character } , "}"\n')),Object(a.b)("h3",{id:"expressions"},"Expressions"),Object(a.b)("pre",null,Object(a.b)("code",Object(n.a)({parentName:"pre"},{}),'expression      = unary\n                | binary\n                | conditional\n                | function_call\n                | variable_access\n                | grouping\n                | literal\n\nunary           = operator , expression\nbinary          = expression , operator , expression\nconditional     = "if" , expression , expression , "else" , expression\nfunction_call   = identifier , "(" , [ identifier_typed ] , { "," , identifier_typed } , ")"\nvariable_access = identifier\ngrouping        = "(" , expression , ")"\n')))}d.isMDXComponent=!0}}]);