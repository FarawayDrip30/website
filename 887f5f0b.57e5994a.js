(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{146:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return c})),n.d(t,"metadata",(function(){return l})),n.d(t,"rightToc",(function(){return b})),n.d(t,"default",(function(){return s}));var a=n(2),i=n(9),r=(n(0),n(161)),c={id:"grammar",title:"Grammar"},l={id:"specification/grammar",isDocsHomePage:!1,title:"Grammar",description:"Notation",source:"@site/docs/specification/grammar.md",permalink:"/docs/specification/grammar",editUrl:"https://github.com/whistle-lang/website/edit/master/website/docs/specification/grammar.md",sidebar:"someSidebar",previous:{title:"Hello, World!",permalink:"/docs/getting-started/hello-world"},next:{title:"Operators",permalink:"/docs/specification/operators"}},b=[{value:"Notation",id:"notation",children:[]},{value:"Characters, letters and digits",id:"characters-letters-and-digits",children:[]},{value:"Whitespace",id:"whitespace",children:[]},{value:"Comments",id:"comments",children:[]},{value:"Identifiers",id:"identifiers",children:[]},{value:"Keywords",id:"keywords",children:[]},{value:"Operators",id:"operators",children:[]},{value:"Literals",id:"literals",children:[]},{value:"Tips",id:"tips",children:[]},{value:"Expressions",id:"expressions",children:[]},{value:"Statements",id:"statements",children:[]},{value:"Grammar",id:"grammar",children:[]}],o={rightToc:b};function s(e){var t=e.components,n=Object(i.a)(e,["components"]);return Object(r.b)("wrapper",Object(a.a)({},o,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("h2",{id:"notation"},"Notation"),Object(r.b)("p",null,"To describe the grammar fo ",Object(r.b)("em",{parentName:"p"},"Whistle"),", ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form"}),"extended Backus-Naur form (EBNF)"),"\nis used. The following table describes all of the used notations in the grammar specification of ",Object(r.b)("em",{parentName:"p"},"Whistle"),"."),Object(r.b)("table",null,Object(r.b)("thead",{parentName:"table"},Object(r.b)("tr",{parentName:"thead"},Object(r.b)("th",Object(a.a)({parentName:"tr"},{align:null}),"usage"),Object(r.b)("th",Object(a.a)({parentName:"tr"},{align:null}),"notation"))),Object(r.b)("tbody",{parentName:"table"},Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"definition"),Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:null}),Object(r.b)("inlineCode",{parentName:"td"},"="))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"concatination"),Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:null}),Object(r.b)("inlineCode",{parentName:"td"},","))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"alteration"),Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:null}),Object(r.b)("code",null,"|"))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"optional"),Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:null}),Object(r.b)("inlineCode",{parentName:"td"},"["),", ",Object(r.b)("inlineCode",{parentName:"td"},"]"))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"repetition"),Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:null}),Object(r.b)("inlineCode",{parentName:"td"},"{"),", ",Object(r.b)("inlineCode",{parentName:"td"},"}"))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"grouping"),Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:null}),Object(r.b)("inlineCode",{parentName:"td"},"("),", ",Object(r.b)("inlineCode",{parentName:"td"},")"))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"string"),Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:null}),Object(r.b)("inlineCode",{parentName:"td"},'"'),", ",Object(r.b)("inlineCode",{parentName:"td"},'"'))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"exception"),Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:null}),Object(r.b)("inlineCode",{parentName:"td"},"-"))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"range"),Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:null}),Object(r.b)("inlineCode",{parentName:"td"},"..."))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"comment"),Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:null}),Object(r.b)("inlineCode",{parentName:"td"},"//"))),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"comment"),Object(r.b)("td",Object(a.a)({parentName:"tr"},{align:null}),Object(r.b)("inlineCode",{parentName:"td"},"/*"),", ",Object(r.b)("inlineCode",{parentName:"td"},"*/"))))),Object(r.b)("h2",{id:"characters-letters-and-digits"},"Characters, letters and digits"),Object(r.b)("p",null,"There are a few predefined values that could not easily be written as valid EBNF, these are instead written with the value of a comment which describes its content."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),'unicode_char      = // any Unicode code point except newline\nunicode_letter    = // any Unicode code point classified as a "Letter"\nunicode_digit     = // any Unicode code point classified as a "Digit"\n\nletter            = unicode_letter | "_"\ndigits_decimal    = { "0" ... "9" }\ndigits_binary     = { "0" | "1" }\ndigits_octal      = { "0" ... "7" }\ndigits_hex        = { "0" ... "9" | "A" ... "F" | "a" ... "f" }\n')),Object(r.b)("h2",{id:"whitespace"},"Whitespace"),Object(r.b)("p",null,"In ",Object(r.b)("em",{parentName:"p"},"Whistle")," whitespace serves no purpose but to separate tokens and if included in a literal that explicitly allows it (string and character literals)."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),'whitespace = " " | "\\t" | "\\r" | "\\n"\n')),Object(r.b)("h2",{id:"comments"},"Comments"),Object(r.b)("p",null,"Just like whitespace comments get ignored unless it is in a literal that explicitly allows it. ",Object(r.b)("em",{parentName:"p"},"Whistle")," provides two comment types: line comments and multiline/inline comments."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),'comment        = comment_line | comment_inline\ncomment_line   = "//" , { unicode_char } , "\\n"\ncomment_inline = "/*" , { unicode_char } , "*/"\n')),Object(r.b)("h2",{id:"identifiers"},"Identifiers"),Object(r.b)("p",null,"Identifiers are mainly used in ",Object(r.b)("em",{parentName:"p"},"Whistle")," to name certain entities such as types, functions and variables. Some identifiers however are reserved as keywords and are not allowed for naming."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),'ident        = letter , { letter | unicode_digit }\nident_typed  = ident , ":" , ident\nident_as     = ident , "as" , ident\nident_import = ident_as | ident\n')),Object(r.b)("h2",{id:"keywords"},"Keywords"),Object(r.b)("p",null,"The following identifiers reserved as keywords in ",Object(r.b)("em",{parentName:"p"},"Whistle")," are currently:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"import    as        from\nexport    fun       return\nif        else      while\nbreak     continue  var\nval\n")),Object(r.b)("p",null,"And here are some of the planned keywords:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"for       in        match\ntype      struct    trait\n")),Object(r.b)("h2",{id:"operators"},"Operators"),Object(r.b)("p",null,"Operators are defined by one or more operator characters coming after each other."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),'operator_unary     = "-"   | "!"   | "~"\noperator_binary    = "+"   | "-"   | "*"   | "/"   | "%"   | "**"  | "=="\n                   | "!="  | "<="  | "<"   | ">"   | ">="  | "&&"  | "||"\n                   | "<<"  | ">>"  | "&"   | "|"   | "^"   | "+="  | "-="\n                   | "*"=  | "/="  | "%="  | "**=" | "&&=" | "||=" | "<<="\n                   | ">>=" | "&="  | "|="  | "^="  | operator_assign\noperator_assign    = "="\n')),Object(r.b)("h2",{id:"literals"},"Literals"),Object(r.b)("p",null,"Literals in ",Object(r.b)("em",{parentName:"p"},"Whistle")," represent a fixed value."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),'literal     = int\n            | float\n            | string\n            | char\n            | bool\n            | none\n\nint         = int_decimal\n            | int_binary\n            | int_octal\n            | int_hex\nint_decimal = digits_decimal\nint_binary  = "0" , ( "b" | "B" ) , digits_binary\nint_octal   = "0" , ( "o" | "O" ) , digits_octal\nint_hex     = "0" , ( "x" | "X" ) , digits_hex\n\nfloat       = ( digits_decimal , "." , [ digits_decimal ] , [ exponent ] )\n            | ( digits_decimal , exponent )\n            | ( "." , digits_decimal , exponent )\nexponent    = ( "e" | "E" ) , [ "+" | "-" ] , digits_decimal\n\nstring      = "\\"" , { unicode_char - "\\"" | "\\n" } , "\\""\n\nchar        = "\'" , ( unicode_char - "\\\'" | "\\n" ) , "\'"\n\nbool        = "true" | "false"\n\nnone        = "none"\n')),Object(r.b)("h2",{id:"tips"},"Tips"),Object(r.b)("p",null,"Tips are in ",Object(r.b)("em",{parentName:"p"},"Whistle")," similar to macros. They tell the compiler certain stuff\nand are very useful for a plethera of reasons. There are two types of tips in\n",Object(r.b)("em",{parentName:"p"},"Whistle"),": line tips and multiline/inline tips."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),'tip       = "#(" , ident ,  ")" , ( tip_line | tip_block )\ntip_line  =  { unicode_char } , "\\n"\ntip_block = "{" , { unicode_char } , "}"\n')),Object(r.b)("h2",{id:"expressions"},"Expressions"),Object(r.b)("p",null,"Expressions specify the computation of a value by applying operators to an operands."),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Disclaimers"),":"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"The syntax for conditionals in ",Object(r.b)("em",{parentName:"li"},"Whistle")," is still undecided"),Object(r.b)("li",{parentName:"ul"},"Both index and slice array accessing is not ready along with arrays which is why it is commented")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),'expression      = unary | binary\n\nunary           = primary | ( operator_unary , unary )\nbinary          = expression , operator_binary , expression\n\nprimary         = operand\n                | conditional\n                | ( primary , selector )\n                | ( primary , arguments )\n//              | ( primary , index )\n//              | ( primary , slice )\n\nconditional     = expression , "if" , expression , "else" , expression\noperand         = literal | ident | grouping\ngrouping        = "(" , expression , ")"\nselector        = "." , ident\narguments       = "(" , [ expression , { "," , expression } ] , ")"\n// index        = primary , "[" , expression , "]"\n// slice        = primary , "[" , [ expression ] , ":" , [ expression ] , [ ":" , [ expression ] ] , "]"\n')),Object(r.b)("h2",{id:"statements"},"Statements"),Object(r.b)("p",null,"Statements control the execution and flow of the program."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),'statement = if\n          | while\n          | continue\n          | break\n          | return\n          | var_decl\n          | val_decl\n          | fun_decl\n          | block\n          | import\n          | tip\n          | expression\n\nif        = "if" , expression , statement , [ "else", statement ]\nwhile     = "while" , [ expression ] , statement\ncontinue  = "continue"\nbreak     = "break"\nreturn    = "return" , [ expression ]\nvar_decl  = "var" , ident_typed , operator_assign , expression\nval_decl  = "val" , ident_typed , operator_assign , expression\nfun_decl  = "fun" , ident , { "(" , ident_typed , { "," , ident_typed } ")" } , ":" , ident , statement\nblock     = "{" , { statement } , "}"\nimport    = "import" , [ ident_import , { "," , ident_import } , "from" ] , string\n')),Object(r.b)("h2",{id:"grammar"},"Grammar"),Object(r.b)("p",null,"Finally the grammar of the ",Object(r.b)("em",{parentName:"p"},"Whistle")," programming language can be described as zero or more ",Object(r.b)("inlineCode",{parentName:"p"},"statement"),"s repeating."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"grammar = { statement }\n")))}s.isMDXComponent=!0}}]);