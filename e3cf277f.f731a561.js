(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{150:function(e,t,i){"use strict";i.r(t),i.d(t,"frontMatter",(function(){return c})),i.d(t,"metadata",(function(){return o})),i.d(t,"rightToc",(function(){return l})),i.d(t,"default",(function(){return d}));var n=i(2),a=i(9),r=(i(0),i(160)),c={id:"grammar",title:"Grammar"},o={id:"specification/grammar",isDocsHomePage:!1,title:"Grammar",description:"Notation",source:"@site/docs\\specification\\grammar.md",permalink:"/docs/specification/grammar",editUrl:"https://github.com/whistle-lang/website/edit/master/website/docs/specification/grammar.md",sidebar:"someSidebar",previous:{title:"Hello, World!",permalink:"/docs/getting-started/hello-world"}},l=[{value:"Notation",id:"notation",children:[]},{value:"The Whistle Grammar Specification",id:"the-whistle-grammar-specification",children:[{value:"Characters, letters and digits",id:"characters-letters-and-digits",children:[]},{value:"Whitespace",id:"whitespace",children:[]},{value:"Comments",id:"comments",children:[]},{value:"Identifiers",id:"identifiers",children:[]},{value:"Keywords",id:"keywords",children:[]},{value:"Operators",id:"operators",children:[]},{value:"Number Literals",id:"number-literals",children:[]},{value:"String Literals",id:"string-literals",children:[]},{value:"Char Literals",id:"char-literals",children:[]}]}],s={rightToc:l};function d(e){var t=e.components,i=Object(a.a)(e,["components"]);return Object(r.b)("wrapper",Object(n.a)({},s,i,{components:t,mdxType:"MDXLayout"}),Object(r.b)("h2",{id:"notation"},"Notation"),Object(r.b)("p",null,"To describe the grammar fo ",Object(r.b)("em",{parentName:"p"},"Whistle"),", ",Object(r.b)("a",Object(n.a)({parentName:"p"},{href:"https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form"}),"extended Backus-Naur form (EBNF)"),"\nis used."),Object(r.b)("p",null,"The operator ",Object(r.b)("inlineCode",{parentName:"p"},"...")," represents a range from the toke that comes before to the that comes after as alternatives. For examaple ",Object(r.b)("inlineCode",{parentName:"p"},'"A" ... "C"')," is equivelent to ",Object(r.b)("inlineCode",{parentName:"p"},'"A" | "B" | "C"'),". Line comments are specified using double slashes (",Object(r.b)("inlineCode",{parentName:"p"},"//"),") and continue until a new line character is encountered while multiline comments are nesting and start with ",Object(r.b)("inlineCode",{parentName:"p"},"/*")," and end with ",Object(r.b)("inlineCode",{parentName:"p"},"*/"),"."),Object(r.b)("h2",{id:"the-whistle-grammar-specification"},"The Whistle Grammar Specification"),Object(r.b)("h3",{id:"characters-letters-and-digits"},"Characters, letters and digits"),Object(r.b)("p",null,"There are a few predefined values that could not easily be written as valid EBNF, these are instead written with the value of a comment which describes its content."),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{}),'unicode_character = // any Unicode code point except newline\nunicode_letter    = // any Unicode code point classified as a "Letter"\nunicode_digit     = // any Unicode code point classified as a "Digit"\n\nletter            = unicode_letter | "_"\ndigits_decimal    = { "0" ... "9" }\ndigits_binary     = { "0" | "1" }\ndigits_octal      = { "0" ... "7" }\ndigits_hex        = { "0" ... "9" | "A" ... "F" | "a" ... "f" }\n')),Object(r.b)("h3",{id:"whitespace"},"Whitespace"),Object(r.b)("p",null,"In ",Object(r.b)("em",{parentName:"p"},"Whistle")," whitespace serves no purpose but to separate tokens and if included in a literal that explicitly allows it (string and character literals)."),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{}),'whitespace = " " | "\\t" | "\\r" | "\\n"\n')),Object(r.b)("h3",{id:"comments"},"Comments"),Object(r.b)("p",null,"Just like whitespace comments get ignored unless it is in a literal that explicitly allows it. ",Object(r.b)("em",{parentName:"p"},"Whistle")," provides two comment types: line comments and multiline/inline comments specified as following:"),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{}),'line_comment   = "//" , { unicode_character } , "\\n"\ninline_comment = "/*" , { unicode_character } , "*/"\n')),Object(r.b)("h3",{id:"identifiers"},"Identifiers"),Object(r.b)("p",null,"Identifiers are mainly used in ",Object(r.b)("em",{parentName:"p"},"Whistle")," to name certain entities such as types, functions and variables. Some identifiers however are reserved as keywords and are not allowed for naming."),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{}),"identifier = letter , { letter | unicode_digit }\n")),Object(r.b)("h3",{id:"keywords"},"Keywords"),Object(r.b)("p",null,"The following identifiers reserved as keywords in ",Object(r.b)("em",{parentName:"p"},"Whistle")," are currently:"),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{}),"import    as        from\nexport    fun       return\nif        else      while\nloop      break     continue\nvar       val\n")),Object(r.b)("p",null,"And here are some of the planned keywords:"),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{}),"for       in        match\ntype      struct    trait\n")),Object(r.b)("h3",{id:"operators"},"Operators"),Object(r.b)("p",null,"Operators are defined by one or more operator characters coming after each other."),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{}),'operator_character = "+" | "-" | "*" | "/" | "%" | "^" | "=" | ":" | "." | ";"\n                   | "!" | "|" | "&" | "!" | "<" | ">"\noperator = { operator_character }\n')),Object(r.b)("h3",{id:"number-literals"},"Number Literals"),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{}),'integer         = integer_decimal | integer_binary | integer_octal | integer_hex\ninteger_decimal = digits_decimal\ninteger_binary  = "0" , ( "b" | "B" ) , digits_binary\ninteger_octal   = "0" , ( "o" | "O" ) , digits_octal\ninteger_hex     = "0" , ( "x" | "X" ) , digits_hex\n\nfloat           = ( digits_decimal , "." , [ digits_decimal ] , [ exponent ] )\n                | ( digits_decimal , exponent )\n                | ( "." , digits_decimal , exponent )\nexponent        = ( "e" | "E" ) , [ "+" | "-" ] , digits_decimal\n')),Object(r.b)("h3",{id:"string-literals"},"String Literals"),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{}),'string = "\\"" , { unicode_character | "\\n" } , "\\""\n')),Object(r.b)("h3",{id:"char-literals"},"Char Literals"),Object(r.b)("pre",null,Object(r.b)("code",Object(n.a)({parentName:"pre"},{}),'char = "\'" , ( unicode_character | "\\n" ) , "\'"\n')))}d.isMDXComponent=!0}}]);